ANL ENGENHARIA TI SR – PLATAFORMAS E JORNADAS DE DAILY BANKING
ID: 807222
Inscrições abertas até: 22/01/2026
Nível: Sênior
Local: São Paulo – São Paulo (Modelo Híbrido sem escala)
Squad: PLATAFORMA FATURA
Papel: TEAM MEMBER

Sobre a Vaga
O futuro colaborador irá trabalhar no modelo de comunidade, sendo direcionado para a squad Plataforma Fatura. A atuação será como engenheiro de tecnologia em back-end. A comunidade atende os assuntos relacionados a cartão de crédito, onde os desafios são entregar demandas inovadoras e com retorno ao negócio. As implementações efetivamente estão relacionadas a experiência e engajamento que o cliente vai ter ao usar um cartão de crédito do Itaú.

Requisitos e Experiências
Engenharia de Software: Experiência sólida na área.

		- Experiência sólida em democratização de dados, sei que não está descrito, mas para contextualizar
			- Brainr e Catalogo: Já fui responsável pelo portal que faz gerenciamento das tabelas do mesh (Brainr), onde desenvolvi o BrainrGPT, ferramenta que automatizava descrições de colunas com IA. Também cuidava do Catalogo de Dados, onde havia a da gestão de acessos às tabelas democratizadas, garantindo governança e segurança.

			- Atlan: Contribuí na migração do catálogo corporativo para o Atlan, centralizando todas as tabelas democratizadas em uma plataforma única. Isso trouxe maior organização, rastreabilidade e acesso controlado aos dados.

			- Qualidade e Ciclo de Vida: Atualmente, trabalho na equipe de aferição automática de qualidade das tabelas do data mesh (Hórus). Com isso, conheço todo o ciclo de vida da democratização: criação das tabelas, ingestão, validação de qualidade, gestão de acessos e disponibilização via conta consumer.
		
		- Conhecimento principal em Python, com boas práticas de desenvolvimento, com orientação a objetos, utilizando SOLID, Clean Arch, testes unitarios, testes integrados, ingestão de dependencias, padrões de projeto. Gosto de disseminar projetos que ficaram bons para utilizarem como template.
			- Herança (cachorro É UM animal); COMPOSIÇÃO (carro TEM UM motor); POLIMORFISMO (comportamento muda de acordo com o objeto)
			- SOLID:
				S – Single Responsibility Principle: Cada classe deve ter apenas uma razão para mudar, pois concentrar responsabilidades distintas em um único componente aumenta o acoplamento e dificulta a evolução sustentável do sistema.
				O – Open/Closed Principle: Os módulos devem estar abertos para extensão e fechados para modificação, permitindo evolução contínua sem comprometer a estabilidade do código já validado em produção.
				L – Liskov Substitution Principle: Objetos de subclasses devem poder substituir suas superclasses sem alterar o comportamento esperado, garantindo consistência semântica e preservando contratos de abstração.
				I – Interface Segregation Principle: Interfaces devem ser específicas e coesas, evitando obrigar clientes a depender de métodos que não utilizam, o que reduz fragilidade e promove baixo acoplamento.
				D – Dependency Inversion Principle: Os módulos de alto nível não devem depender de implementações de baixo nível, mas de abstrações, permitindo arquiteturas flexíveis, testáveis e resilientes a mudanças tecnológicas.
				
				SOLID aplicado:
				SRP → classes pequenas e testáveis
				OCP → extensão sem quebrar código existente
				LSP → contratos respeitados
				ISP → interfaces coesas
				DIP → dependência de abstrações

			- Clean Arch: O Clean Architecture organiza o sistema em quatro camadas: Entidades com regras de negócio puras, Casos de Uso que coordenam essas regras, Adaptadores que traduzem dados entre aplicação e mundo externo, e Infraestrutura que contém frameworks e tecnologias. Essa separação garante independência, testabilidade e facilidade de evolução.
			- Piramede de Testes: A pirâmide de testes mostra que devemos ter muitos testes unitários rápidos e baratos na base, uma quantidade moderada de testes de integração para validar interações entre módulos, e poucos testes end-to-end no topo, que são mais caros e lentos. Essa proporção garante qualidade, velocidade e menor custo de manutenção.

		O que é DDD
			Definição: Conjunto de princípios e práticas que priorizam o entendimento profundo do domínio de negócio e sua modelagem no software.
			Objetivo: Reduzir a distância entre especialistas de negócio e desenvolvedores, criando uma linguagem ubíqua (compartilhada por todos).
			Aplicação: Não é uma arquitetura específica, mas pode ser usado em arquiteturas como Clean Architecture, Hexagonal, Onion, CQRS
		
		Arquiteturas:  Clean Architecture, Hexagonal, Onion, CQRS
			- Clean Architecture: Organiza o sistema em camadas concêntricas, mantendo o domínio independente de frameworks e infraestrutura. Use quando precisar organizar o sistema em camadas independentes, mantendo o domínio isolado de frameworks.
			- Hexagonal Architecture: Usa ports & adapters para isolar o núcleo e permitir troca fácil de tecnologias externas. Use quando quiser flexibilidade para trocar tecnologias externas facilmente via ports & adapters.
			- Onion Architecture: Estrutura em camadas como uma cebola, com todas as dependências apontando para o domínio central. Use quando precisar garantir que todas as dependências apontem para o núcleo do domínio.
			- CQRS: Separa leitura e escrita em modelos distintos para otimizar performance e consistência em sistemas complexos. Use quando leitura e escrita têm requisitos distintos e precisam ser otimizadas separadamente.
			
		Padrões de Projeto:
			- Singleton: Garante que exista apenas uma instância de uma classe em todo o sistema. Use quando precisar garantir uma única instância global compartilhada (ex.: gerenciador de configuração).
			- Factory Method: Centraliza a criação de objetos, delegando às subclasses a decisão de qual instância produzir. Use quando quiser delegar às subclasses a lógica de criação de objetos sem acoplar ao tipo concreto.
			- Abstract Factory: Cria famílias de objetos relacionados sem expor suas classes concretas. Use quando precisar criar famílias de objetos relacionados que devem funcionar juntos.
			- Builder: Constrói objetos complexos passo a passo, separando a lógica de criação da representação final. Use quando precisar montar objetos complexos em etapas, mantendo flexibilidade na construção.
			- Prototype: Cria novos objetos copiando instâncias existentes (clonagem). Use quando precisar criar novos objetos rapidamente a partir da clonagem de instâncias existentes.
			- Adapter: Conecta interfaces incompatíveis, permitindo que trabalhem juntas. Use quando precisar integrar sistemas com interfaces incompatíveis sem alterar o código original.
			- Decorator: Adiciona responsabilidades dinamicamente a um objeto sem alterar sua estrutura. Use quando quiser adicionar funcionalidades a objetos de forma dinâmica e transparente.
			- Observer: Define dependência um-para-muitos, notificando automaticamente objetos interessados em mudanças. Use quando precisar notificar automaticamente múltiplos objetos sobre mudanças em um estado.
			- Strategy: Encapsula algoritmos diferentes e permite alterná-los em tempo de execução. Use quando precisar alternar algoritmos ou comportamentos em tempo de execução sem alterar o cliente.
			- Command: Transforma ações em objetos, permitindo filas, logs e desfazer operações. Use quando quiser encapsular ações como objetos para suportar filas, logs ou desfazer operações.
			
Metodologias Ágeis: Desejável experiência prática.
	Sim, conheço
	
APIs: Conhecimento e experiência na construção e integração de APIs RESTful.
	Tenho experiência em trabalhar com APIs RESTful, aplicando boas práticas de design, segurança e documentação. REST é o conjunto de princípios arquiteturais que define como sistemas devem se comunicar de forma padronizada, usando recursos, verbos HTTP e representações. Já RESTful significa colocar esses princípios em prática corretamente, ou seja, construir APIs que realmente seguem o modelo REST (com endpoints bem definidos, versionamento, uso adequado de status codes e documentação via Swagger/OpenAPI). Em AWS, por exemplo, exponho APIs com API Gateway e Lambda, armazeno dados em DynamoDB ou RDS, e monitoro chamadas com CloudWatch, garantindo escalabilidade, segurança e facilidade de integração.
	
Cloud: Experiência em ambiente AWS.
	Certificações AWS
	
Linguagens de Programação: Domínio de Java e/ou Kotlin, Python e framework Spring Boot. (Também citado Golang nos requisitos).
	Conheço mais de Python e um pouco de Java e Spring
	
Infraestrutura: Desenvolvimento de Infraestrutura como código (IaC).
	Tenho pratica
	
Bancos de Dados: Experiência em bancos relacionais e não relacionais noSQL (ex: DynamoDB).
	- Bancos Relacionais (SQL) - Ex: PostgreSQL, MySQL, Oracle
		Foco: Integridade de dados e consistência transacional (ACID).
		Quando usar: * Dados altamente relacionados (ex: Cadastro de Cliente x Conta x Cartão).
		Necessidade de Joins complexos e transações financeiras garantidas.
		Esquema de dados rígido e estruturado.
		Pontos chave: Normalização, índices, chaves estrangeiras e escalabilidade predominantemente vertical (aumentar o servidor).
	- Bancos Não Relacionais (NoSQL) - Ex: DynamoDB, MongoDB, Cassandra
		Foco: Escalabilidade horizontal, alta disponibilidade e flexibilidade.
		Quando usar: * Grandes volumes de dados e alta taxa de leitura/escrita.
		Esquemas flexíveis ou que mudam rápido.
		Performance de baixa latência em escala global.
		Pontos chave: Desnormalização, escalabilidade horizontal (adicionar mais máquinas) e teorema CAP.
	
	- Uso SQL quando a integridade referencial e transações ACID são críticas para o negócio, como no núcleo financeiro. Já o NoSQL (DynamoDB) eu aplico em cenários de alta escala e baixa latência, como o histórico de faturas ou logs de eventos, onde a performance e a disponibilidade global superam a necessidade de Joins complexos.

Mensageria: Experiência com sistemas de mensageria, eventos e streaming.
	Diferença entre Mensageria, Eventos e Streaming
			- Mensageria (Queue/Fila): Foco na entrega de uma tarefa de um ponto A para um ponto B. O produtor sabe o que quer que aconteça.
		Ex: SQS (AWS), RabbitMQ.
			- Eventos (Pub/Sub): O sistema anuncia que algo aconteceu ("Fatura Paga"). Quem estiver interessado que escute. Desacopla totalmente os sistemas.
		Ex: SNS (AWS), EventBridge.
			- Streaming: Fluxo contínuo de dados em tempo real que podem ser reprocessados. Permite analisar sequências de eventos ao longo do tempo.
		Ex: Kafka, Kinesis (AWS).
	
	1. APIs (Request/Response)
	É a integração síncrona. O cliente envia uma requisição e aguarda a resposta imediatamente.
	Quando usar: Consultas de saldo em tempo real, validação de senha ou qualquer ação que o usuário precise da confirmação instantânea para prosseguir.
	Padrões: REST (JSON/HTTP), gRPC (para comunicação rápida entre microsserviços) ou GraphQL (para o front-end buscar apenas o que precisa).
	Desvantagem: Se o serviço de destino estiver fora do ar, a chamada falha (acoplamento temporal).

	2. Mensageria (Point-to-Point)
	Integração assíncrona baseada em filas. O produtor coloca a mensagem na fila e "esquece".
	Quando usar: Processamento de tarefas pesadas que não precisam ser instantâneas, como gerar o PDF de uma fatura ou enviar um SMS de confirmação.
	Ferramentas: AWS SQS, RabbitMQ.
	Vantagem: Garante que a mensagem será processada eventualmente, mesmo que o sistema de destino sofra um pico de carga (buffering).

	3. Event-Driven (Pub/Sub)
	O sistema reage a mudanças de estado (eventos). Um serviço publica que "A Fatura foi Paga" e outros serviços reagem a isso.
	Quando usar: Para desacoplar sistemas. O serviço de Pagamento não precisa saber que o serviço de "Pontos/Fidelidade" existe; ele apenas publica o evento.
	Ferramentas: AWS SNS, EventBridge.
	Vantagem: Facilidade para adicionar novas funcionalidades sem mexer no código dos serviços antigos.

	4. Streaming (Data in Motion)
	Processamento de um fluxo contínuo de dados em tempo real.
	Quando usar: Detecção de fraude em cartões (analisar o comportamento de várias compras seguidas), auditoria (log de tudo que acontece) ou alimentação de Dashboards em tempo real.
	Ferramentas: AWS Kinesis, Apache Kafka.
	Vantagem: Permite "voltar no tempo" e reprocessar dados antigos, além de suportar um volume massivo de informações.

Cultura DevOps: Mentalidade "You build it, you run it", participando desde o design de microsserviços até o deployment e sustentação em produção.

Code Review: Participar ativamente indicando pontos de melhoria e otimização.

Responsabilidades
Projetar e evoluir arquiteturas de sistemas.
Selecionar padrões de integração (APIs, mensageria, streaming, event-driven).
Avaliar e incorporar novas tecnologias, garantindo aderência às políticas corporativas.
Sustentar plataformas críticas, implementando melhorias permanentes.
Projetar e desenvolver infraestruturas seguras em cloud.
Auxiliar a squad com padrões, boas práticas e tomada de decisões técnicas.
Realizar revisões de arquitetura, código e deploy.
Orientar analistas e engenheiros menos experientes e disseminar boas práticas de engenharia.
