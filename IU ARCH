Resumo da Vaga: Engenheiro de TI S√™nior
Squad: IU ARCH
Papel: TEAM MEMBER
Local: S√£o Paulo ‚Äì S√£o Paulo
Modelo de Trabalho: H√≠brido sem escala

Sobre a vaga
Busca-se um Engenheiro de TI S√™nior para o projeto IU Arch, focado em avalia√ß√£o de arquiteturas de contas e projetos em AWS. O profissional atuar√° no desenvolvimento e evolu√ß√£o do sistema, com foco em performance, escalabilidade, an√°lise de arquiteturas e atua√ß√£o fullstack.

Requisitos T√©cnicos
Cloud: Experi√™ncia s√≥lida em AWS (EC2, S3, IAM, CloudFormation, Lambda, etc.).

	- Falar das certifica√ß√µes AWS
	
	- Experi√™ncia s√≥lida em democratiza√ß√£o de dados, sei que n√£o est√° descrito, mas para contextualizar
			- Brainr e Catalogo: J√° fui respons√°vel pelo portal que faz gerenciamento das tabelas do mesh (Brainr), onde desenvolvi o BrainrGPT, ferramenta que automatizava descri√ß√µes de colunas com IA. Tamb√©m cuidava do Catalogo de Dados, onde havia a da gest√£o de acessos √†s tabelas democratizadas, garantindo governan√ßa e seguran√ßa.

			- Atlan: Contribu√≠ na migra√ß√£o do cat√°logo corporativo para o Atlan, centralizando todas as tabelas democratizadas em uma plataforma √∫nica. Isso trouxe maior organiza√ß√£o, rastreabilidade e acesso controlado aos dados.

			- Qualidade e Ciclo de Vida: Atualmente, trabalho na equipe de aferi√ß√£o autom√°tica de qualidade das tabelas do data mesh (H√≥rus). Com isso, conhe√ßo todo o ciclo de vida da democratiza√ß√£o: cria√ß√£o das tabelas, ingest√£o, valida√ß√£o de qualidade, gest√£o de acessos e disponibiliza√ß√£o via conta consumer.
			
Arquitetura: Forte conhecimento em arquitetura de sistemas e boas pr√°ticas de cloud.

	- Boas praticas: Princ√≠pio do Privil√©gio M√≠nimo, Otimiza√ß√£o de Custos, Confiabilidade/Design para Falhas, 

	- Arquitetura e Desenvolvimento e Dom√≠nio de SOLID, Design Patterns e Orienta√ß√£o a Objetos (OOP)
			- Conhecimento principal em Python, com boas pr√°ticas de desenvolvimento, com orienta√ß√£o a objetos, utilizando SOLID, Clean Arch, testes unitarios, testes integrados, ingest√£o de dependencias, padr√µes de projeto. Gosto de disseminar projetos que ficaram bons para utilizarem como template.
			- Heran√ßa (cachorro √â UM animal); COMPOSI√á√ÉO (carro TEM UM motor); POLIMORFISMO (comportamento muda de acordo com o objeto)
			- SOLID:
				S ‚Äì Single Responsibility Principle: Cada classe deve ter apenas uma raz√£o para mudar, pois concentrar responsabilidades distintas em um √∫nico componente aumenta o acoplamento e dificulta a evolu√ß√£o sustent√°vel do sistema.
				O ‚Äì Open/Closed Principle: Os m√≥dulos devem estar abertos para extens√£o e fechados para modifica√ß√£o, permitindo evolu√ß√£o cont√≠nua sem comprometer a estabilidade do c√≥digo j√° validado em produ√ß√£o.
				L ‚Äì Liskov Substitution Principle: Objetos de subclasses devem poder substituir suas superclasses sem alterar o comportamento esperado, garantindo consist√™ncia sem√¢ntica e preservando contratos de abstra√ß√£o.
				I ‚Äì Interface Segregation Principle: Interfaces devem ser espec√≠ficas e coesas, evitando obrigar clientes a depender de m√©todos que n√£o utilizam, o que reduz fragilidade e promove baixo acoplamento.
				D ‚Äì Dependency Inversion Principle: Os m√≥dulos de alto n√≠vel n√£o devem depender de implementa√ß√µes de baixo n√≠vel, mas de abstra√ß√µes, permitindo arquiteturas flex√≠veis, test√°veis e resilientes a mudan√ßas tecnol√≥gicas.
				
				SOLID aplicado:
				SRP ‚Üí classes pequenas e test√°veis
				OCP ‚Üí extens√£o sem quebrar c√≥digo existente
				LSP ‚Üí contratos respeitados
				ISP ‚Üí interfaces coesas
				DIP ‚Üí depend√™ncia de abstra√ß√µes

			- Clean Arch: O Clean Architecture organiza o sistema em quatro camadas: Entidades com regras de neg√≥cio puras, Casos de Uso que coordenam essas regras, Adaptadores que traduzem dados entre aplica√ß√£o e mundo externo, e Infraestrutura que cont√©m frameworks e tecnologias. Essa separa√ß√£o garante independ√™ncia, testabilidade e facilidade de evolu√ß√£o.
			- Piramede de Testes: A pir√¢mide de testes mostra que devemos ter muitos testes unit√°rios r√°pidos e baratos na base, uma quantidade moderada de testes de integra√ß√£o para validar intera√ß√µes entre m√≥dulos, e poucos testes end-to-end no topo, que s√£o mais caros e lentos. Essa propor√ß√£o garante qualidade, velocidade e menor custo de manuten√ß√£o.

		O que √© DDD
			Defini√ß√£o: Conjunto de princ√≠pios e pr√°ticas que priorizam o entendimento profundo do dom√≠nio de neg√≥cio e sua modelagem no software.
			Objetivo: Reduzir a dist√¢ncia entre especialistas de neg√≥cio e desenvolvedores, criando uma linguagem ub√≠qua (compartilhada por todos).
			Aplica√ß√£o: N√£o √© uma arquitetura espec√≠fica, mas pode ser usado em arquiteturas como Clean Architecture, Hexagonal, Onion, CQRS
		
		Arquiteturas:  Clean Architecture, Hexagonal, Onion, CQRS
			- Clean Architecture: Organiza o sistema em camadas conc√™ntricas, mantendo o dom√≠nio independente de frameworks e infraestrutura. Use quando precisar organizar o sistema em camadas independentes, mantendo o dom√≠nio isolado de frameworks.
			- Hexagonal Architecture: Usa ports & adapters para isolar o n√∫cleo e permitir troca f√°cil de tecnologias externas. Use quando quiser flexibilidade para trocar tecnologias externas facilmente via ports & adapters.
			- Onion Architecture: Estrutura em camadas como uma cebola, com todas as depend√™ncias apontando para o dom√≠nio central. Use quando precisar garantir que todas as depend√™ncias apontem para o n√∫cleo do dom√≠nio.
			- CQRS: Separa leitura e escrita em modelos distintos para otimizar performance e consist√™ncia em sistemas complexos. Use quando leitura e escrita t√™m requisitos distintos e precisam ser otimizadas separadamente.
			
		Padr√µes de Projeto:
			- Singleton: Garante que exista apenas uma inst√¢ncia de uma classe em todo o sistema. Use quando precisar garantir uma √∫nica inst√¢ncia global compartilhada (ex.: gerenciador de configura√ß√£o).
			- Factory Method: Centraliza a cria√ß√£o de objetos, delegando √†s subclasses a decis√£o de qual inst√¢ncia produzir. Use quando quiser delegar √†s subclasses a l√≥gica de cria√ß√£o de objetos sem acoplar ao tipo concreto.
			- Abstract Factory: Cria fam√≠lias de objetos relacionados sem expor suas classes concretas. Use quando precisar criar fam√≠lias de objetos relacionados que devem funcionar juntos.
			- Builder: Constr√≥i objetos complexos passo a passo, separando a l√≥gica de cria√ß√£o da representa√ß√£o final. Use quando precisar montar objetos complexos em etapas, mantendo flexibilidade na constru√ß√£o.
			- Prototype: Cria novos objetos copiando inst√¢ncias existentes (clonagem). Use quando precisar criar novos objetos rapidamente a partir da clonagem de inst√¢ncias existentes.
			- Adapter: Conecta interfaces incompat√≠veis, permitindo que trabalhem juntas. Use quando precisar integrar sistemas com interfaces incompat√≠veis sem alterar o c√≥digo original.
			- Decorator: Adiciona responsabilidades dinamicamente a um objeto sem alterar sua estrutura. Use quando quiser adicionar funcionalidades a objetos de forma din√¢mica e transparente.
			- Observer: Define depend√™ncia um-para-muitos, notificando automaticamente objetos interessados em mudan√ßas. Use quando precisar notificar automaticamente m√∫ltiplos objetos sobre mudan√ßas em um estado.
			- Strategy: Encapsula algoritmos diferentes e permite altern√°-los em tempo de execu√ß√£o. Use quando precisar alternar algoritmos ou comportamentos em tempo de execu√ß√£o sem alterar o cliente.
			- Command: Transforma a√ß√µes em objetos, permitindo filas, logs e desfazer opera√ß√µes. Use quando quiser encapsular a√ß√µes como objetos para suportar filas, logs ou desfazer opera√ß√µes.

Machine Learning: Experi√™ncia com modelagem, treinamento, avalia√ß√£o e deploy (TensorFlow, PyTorch, Scikit-learn).
	
	Conhe√ßo o ciclo em Machine Learning, cobrindo todo o ciclo de vida: modelagem, treinamento, avalia√ß√£o e deploy.
	Modelagem:
		Defini√ß√£o de problemas e escolha de algoritmos adequados (regress√£o, classifica√ß√£o, redes neurais, √°rvores de decis√£o).
		Uso de Scikit-learn para prototipagem r√°pida e modelos cl√°ssicos.
		Aplica√ß√£o de TensorFlow e PyTorch para arquiteturas mais complexas, como redes neurais profundas e modelos de NLP ou vis√£o computacional.

	Treinamento:
		Pr√©-processamento de dados (normaliza√ß√£o, feature engineering, balanceamento de classes).
		Treinamento em GPU/TPU para acelerar redes neurais.
		Ajuste de hiperpar√¢metros com t√©cnicas como Grid Search, Random Search e Bayesian Optimization.

	Avalia√ß√£o:
		Uso de m√©tricas adequadas ao problema: accuracy, precision, recall, F1-score, ROC-AUC para classifica√ß√£o; RMSE, MAE, R¬≤ para regress√£o.
		Valida√ß√£o cruzada e an√°lise de overfitting/underfitting.
		Interpreta√ß√£o de modelos com ferramentas como SHAP e LIME para explicar decis√µes.

	Deploy:
		Cria√ß√£o de APIs com Flask/FastAPI para servir modelos.
		Deploy em AWS (SageMaker, Lambda, ECS) ou containers com Docker/Kubernetes.
		Monitoramento de modelos em produ√ß√£o (drift de dados, re-treinamento peri√≥dico).
	
	Tipos de redes neurais:
		MLP (Perceptron Multicamadas): redes totalmente conectadas, usadas em classifica√ß√£o e regress√£o.
		CNN (Convolucionais): especializadas em imagens e vis√£o computacional, extraem padr√µes locais.
		RNN (Recorrentes): tratam dados sequenciais (texto, √°udio, s√©ries temporais); variantes LSTM e GRU resolvem mem√≥ria de longo prazo.
		GAN (Generativas Advers√°rias): gerador + discriminador, criam dados sint√©ticos como imagens realistas.
		Autoencoders: usados para compress√£o, reconstru√ß√£o e detec√ß√£o de anomalias.
		Transformers: baseados em aten√ß√£o, dominam NLP (tradu√ß√£o, chatbots, sumariza√ß√£o).
		Arquiteturas espec√≠ficas: U-Net (segmenta√ß√£o de imagens m√©dicas), Diffusion Models (gera√ß√£o de imagens), PINNs (problemas f√≠sicos).
	
	- O Amazon SageMaker √© o servi√ßo da AWS voltado para Machine Learning tradicional e Deep Learning, que cobre todo o ciclo de vida de modelos: prepara√ß√£o de dados, modelagem, treinamento, avalia√ß√£o e deploy. Diferente do Bedrock (que foca em IA generativa com modelos prontos), o SageMaker √© usado para criar e treinar seus pr√≥prios modelos com bibliotecas como TensorFlow, PyTorch e Scikit-learn.
	
	- O Amazon Bedrock √© um servi√ßo da AWS voltado para IA generativa, que permite acessar modelos de base (foundation models) de diferentes provedores sem precisar treinar ou gerenciar infraestrutura. Ele oferece uma API simples para consumir modelos de texto, imagem e multimodais, al√©m de recursos para fine-tuning leve, prompt engineering e cria√ß√£o de agentes inteligentes.
	Com o Bedrock, empresas podem:
		Prototipar rapidamente aplica√ß√µes de IA generativa (chatbots, assistentes, gera√ß√£o de conte√∫do).
		Integrar modelos aos seus dados corporativos por meio de bases de conhecimento.
		Fazer deploy seguro e escal√°vel usando a infraestrutura da AWS, integrada com servi√ßos como API Gateway, Lambda, ECS/EKS e SageMaker.
		Garantir seguran√ßa e compliance com IAM, criptografia e pol√≠ticas da AWS.
		
Desenvolvimento Fullstack:
Front-end: React, Angular ou Vue.js.
	N√£o tenho conhecimento
	
Back-end: Node.js, Python (Django/Flask), APIs REST/GraphQL.
	
	üîπ REST
		Sistemas simples e padronizados:  
		Exemplo: uma API de cadastro de clientes com endpoints como /clientes, /clientes/{id}.
		‚Üí F√°cil de implementar, ideal quando as opera√ß√µes s√£o bem definidas e n√£o mudam muito.

		Integra√ß√µes com servi√ßos legados:  
		Exemplo: sistemas antigos de ERP ou CRM que j√° exp√µem APIs REST.
		‚Üí REST √© padr√£o de mercado, ent√£o facilita integra√ß√£o com sistemas existentes.

		APIs p√∫blicas com cache eficiente:  
		Exemplo: uma API de previs√£o do tempo ou cota√ß√£o de moedas.
		‚Üí Como os dados s√£o consumidos por milhares de clientes, o cache HTTP nativo do REST ajuda a reduzir custo e lat√™ncia.

	üîπ GraphQL
		Aplica√ß√µes com front-end din√¢mico (React, Angular, mobile):  
		Exemplo: um app mobile que precisa mostrar dados de usu√°rio, posts e coment√°rios em uma √∫nica tela.
		‚Üí Com GraphQL, o cliente pede exatamente os campos necess√°rios em uma √∫nica requisi√ß√£o, evitando m√∫ltiplos endpoints.

		Cen√°rios com m√∫ltiplos clientes consumindo dados diferentes:  
		Exemplo: um sistema de e-commerce com web, mobile e dashboards internos.
		‚Üí Cada cliente pode consultar apenas os dados que precisa, sem depender de vers√µes diferentes da API.

		Necessidade de evitar overfetching/underfetching:  
		Exemplo: em REST, um endpoint /produtos pode trazer dados demais (overfetching) ou faltar informa√ß√µes (underfetching).
		‚Üí Com GraphQL, o cliente define os campos exatos, evitando desperd√≠cio de banda e garantindo efici√™ncia.

Dados: Experi√™ncia com bancos de dados (SQL e NoSQL).
	Conhe√ßo banco de dados relacional e n√£o relacional

DevOps: Conhecimento em Infraestrutura como C√≥digo (IaC), automa√ß√£o e pr√°ticas de CI/CD.

Responsabilidades
Defini√ß√£o da estrat√©gia t√©cnica e colabora√ß√£o com equipes de arquitetura e engenharia.
Garantir seguran√ßa, governan√ßa e compliance em AWS.
Integra√ß√£o de dados para an√°lise e gera√ß√£o de insights.
Cria√ß√£o de interfaces intuitivas e responsivas.
Desenvolvimento de algoritmos de ML para melhorias e otimiza√ß√µes.
